<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script>
        var arr = [10, 20, 30, 5, 8,20,40,10];
        var arr2 = ['撒旦', '阿达'];
        //判断一个变量是不是数组，静态方法
        console.log(Array.isArray(arr));
        //连接两个或多个数组,但不会改原数组，会返回一个连接后的新数组
        var arr3 = arr.concat(arr2);
        console.log(arr3);
        //every里面的函数遍历整个数组，可以用来判断数组里面的元素是否符合某种规范，函数每遍历一次都要返回一个Boolean值，只有遍历完成后，每个Boolean都为true时，every方法才返回true，返回的值里面只要出现一个false立马结束遍历，整体返回false
        console.log(arr.every(function (ele, index) {
            return ele > 3;
        }));
        //filter方法和every差不多，不过一个是返回Boolear值，一个是返回符合条件的元素，并用返回的元素组成一个新的数组，所以整个方法返回的是一个数组
        console.log(arr.filter(function (ele, index) {
            return ele > 3;
        }));
        //push和unshift都是往数组里面添加新的元素，不过push是添加在末尾，unshift是添加在开头,两个方法返回值都是新数组的长度
        console.log(arr2.push(arr));
        console.log(arr2);
        console.log(arr2.unshift(arr3));
        console.log(arr2);
        //遍历数组,没有返回值
        arr.forEach(function (ele, index) {
            console.log(ele + "===" + index);
        });
        //在数组内寻找indexOf括号里面的元素，找到则返回该位置的索引，没找到则返回-1
        console.log(arr.indexOf(30));
        //在从数组索引0开始到length-1结束的元素(不包括length-1)末尾加上join里的字符(就算join里面输入的是数字，系统也会自动将它转成字符串)，然后连接这些新元素成新的字符串并返回
        console.log(arr.join(1));
        //反转数组里的元素
        console.log(arr2.reverse());
        //类似冒泡排序
        arr.sort(function(a,b){
            if(a>b) {
                return 1;
            }else if(a==b) {
                return 0;
            }
            else {
                return -1;
            }
        });
        console.log(arr);
        //仿sort
        function newSort(arr, x, y) {
            var i = x;
            var j = y;
            if (arr[i] > arr[j]) {
                var num = arr[i];
                arr[i] = arr[j];
                arr[j] = num;
                if (i - 1 >= 0 && j - 1 >= 0) {
                    newSort(arr, --i, --y);
                }
            }
            if (i + 1 < arr.length && y + 1 < arr.length) {
                newSort(arr, ++i, ++y);
            }


        }
        newSort(arr, 0, 1);
        console.log(arr);
        //slice(x,y) 从x索引位置开始到y-1索引位置结束，截取这之间的元素组成新数组并返回
        console.log(arr.slice(1,3));
        //splice(x,y,z) 从x索引位置开始，删除包括x位置往后的y个元素，z如果有值得话，在x索引位置插入z，没有的话则只删除,返回值为删除的y个数组成的数组
        console.log(arr.splice(1,3,50));

        console.log(arr);

    </script>
</head>

<body>

</body>

</html>